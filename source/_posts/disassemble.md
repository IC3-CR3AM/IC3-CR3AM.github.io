---
title: c++反汇编小结（1）
date: 2020-07-20 14:03:16
tags: disassemble
---
{% img https://wesite-1257887066.cos.ap-shanghai.myqcloud.com/smallPic%2F62799720_p1.jpg %}

## 前言
有些太基础的东西就没不记录了。仅作为查漏补缺
## 基础数据类型
略，和c基本没区别。  

### 引用
稍微讲一下**引用**，很多资料写的不是很清楚  

c++中引用就是指针的封装，通过编译器来限制程序员不能随意修改指针指向的内存地址，并且做到了访问引用就能访问到变量中的数据，向程序员隐藏了中间间接寻址的过程。  
创造引用的目的是为了简化指针操作，防止误操作。在汇编级别上，只有指针没有引用这个东西。

### 常量
由#define修饰后会被编译为立即数寻址。  
由const修饰的变量本质上还是变量，在编译期间检测是否有修改过。因为本身还是变量，所以通过指针的方式获取，并且强制类型转换就可以修改。
那么被const修饰的变量本身也不会像真常量一样放在常量数据区，而是通过作用域决定在内存中的位置。

## 启动函数
一般由mainCRTStartUp函数作为从kernal32出来的程序入口（入口函数名可能会变，总共有四种）。
主要负责堆内存的初始化，main函数所需要的三个参数的初始化，分别为argc，argv，env。

PS：在OllyDbg中需要手动找main，可以一起寻找进入main函数前的一些初始化函数，比如getCommandLineA，再顺着往下找，看到三次参数压栈就知道马上要进入main了。

## 函数调用方式
vc++下有三种调用方式_cdecl,_stdcall,_fastcall

    _cdecl：是默认调用方式，调用者负责平衡栈，不定参数的函数可以使用  
    _stdcall：被调用者平衡栈，不定参数的函数无法使用  
    _fastcall：比_stdcall多了一个用寄存器来传递参数  
    
PS，在优化后，可能出现集中在一起进行一次栈平衡的操作

### 对形参/实参的汇编新解
新生学c的时候总有个问题，为什么在写第一个交换变量函数里不能用形参，而是要用指针  
其实汇编内部是用栈传参，是将原本寄存器或者内存的数据拷贝一份进行压栈，这个时候栈桢内部是个数据备份  
所以要通过传指针，间接的方式来访问真实的原数据

### 不定长参数函数
定义

    至少一个参数  
    每个参数定长，为dword型  
    需要在某一参数中定下总长度或者结束符
    
这样只要访问到第一个参数的地址，除了double型的，都能通过地址+4来获取下一个地址  
另，像printf函数，是在第一个参数就决定了参数列表的长度，通过判断%的个数

### 函数方面小结【基础知识点】
    1.参数传递：通过栈或者寄存器传参  
    2.函数调用：也就是call调用，这个时候会将返回地址压栈，也就会esp+4  
    3.保存栈底：在形成栈桢的时刻，先将ebp压栈，再更新ebp为新的esp地址  
    4.栈平衡：因为不定长参数列表，所以函数自身无法确定所使用多少栈空间，所以用ret指针进行栈平衡（非__cdecl下）；__cdecl下是直接调整esp  
    5.ret指令：一般是近跳转，可以解释为pop ip；但是有ret 4的写法，含义为，pop ip；add esp 4；  

## 变量
### 全局和局部变量
全局变量是在链接的时候直接写入PE文件，存在PE的可读写节中  
在程序运行到main之前，全局变量就已经加载完毕  
局部变量的生命周期，在超出作用域之后，会被栈平衡的时候释放空间  
上面混用了生命周期和作用域，是因为对于局部变量在花括号内，作用域和生命周期是一致的  
局部变量无法访问作用域外的空间，是因为编译器会在编译前进行检查，来限制对外访问  

#### 访问方式
局部变量通过栈指针间接访问  
而全局变量访问是通过在编译期间算好的具体地址，直接通过立即数访问

冷知识：全局变量在内存中是从低地址到高地址，和局部变量相反

### 局部静态变量
全局静态变量和全局变量在汇编层面上是完全一致的，只是在编译期间，编译器限制全局静态变量不能访问其他文件  
局部静态变量也是和全局变量存在同一个节里，生命周期也和全局变量一致，只是使用的时候对它进行赋值。  
规定了只能一次初始化，但是对于局部静态变量都是赋值，所以编译器会生成一个标志比特，置为一则是代表已经初始化过，避免多次初始化  
然后通过名称粉碎法的方式来限制它的作用域，将原有的名称改成**名称+作用域+类型**等  

PS：c++的函数重载也是用的同一种技术

### 堆变量
#### malloc和new的区别
malloc通常需要申请划分一块新的内存，而new直接使用已经申请好的空闲块

PS：debug模式下，堆数据空间内的gap前后四个字节标为0xFD，用来检测越界


