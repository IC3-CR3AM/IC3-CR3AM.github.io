---
title: gost+Socks5多级代理抓包分析
date: 2024-04-18 23:33:38
tags:
---

网上找了一圈没有看到socks5在多跳环境下它是如何实现的，于是动手做了个小实验

## 环境配置

启用了三台ubuntu虚拟机，使用gost设置了三个socks5代理，端口分别在5555、6666、7777上，使用proxychains依次代理。IP依次从143~145

发了一个curl包访问cn.bing.com

wireshark在nat网卡上抓包

### 实验1

这里抓不到curl访问本机的发起流量，从外部看结果如何

![Untitled](Untitled.png)

首先是143发起向144发起的6666端口三次tcp握手，接下来就是socks5的2rtt的交互，从写本之前的实验来看，第三个rtt应该是传输下一跳的ip和port

结果这里是tls加密流量

![Untitled](Untitled_1.png)

看了下gost，果然

![Untitled](Untitled_2.png)

关掉加密再试一下，这次从proxy checker发起做测试，这样能抓到5555端口

由于不是proxychain做chain代理，流量又不一样了

**目前的结果**

在第七个包告诉第一个socks代理节点，最终的目的url。16进制搜索了一下，总共出现了三次，意味着每一个代理都知道目的地址。

![Untitled](Untitled_3.png)

按照时间顺序梳理下来

1. 首先本机与5555建立连接，告知5555也就是第一跳代理目的地址是哪里
2. 第一跳根据gost的设置，与第二跳建立连接，并告知第二跳，最终第三跳目的地
3. 第二跳与第三跳建立连接，并告知第三跳后一跳的目的地，结果发现没变，于是从栈里依次回退
4. 回退到告知每一跳最终目的地的url
5. 最后第三跳也就是最后一跳开始查询dns并建立http连接
6. 数据传输。。。

### 实验2

**使用proxychains在第四台虚拟机访问，抓流量，gost也提前设置好转发链**

![Untitled](Untitled_4.png)

这里是从序号3开始，所以第七个包是序号10

可以看到这里第七个包是不一样的，这里是下一跳的ip和端口

跟上个实验类似，这里也是递归，无非是一个个先与下一跳建立连接，再传输数据，但是依然会在每一跳上传输目的地址，然后能在某一跳中看到全部的http流量

![Untitled](Untitled_5.png)

![Untitled](Untitled_6.png)

### 实验3

**最后一个实验，拆除gost转发链**

上面的类似，这里的逻辑是每一跳单独和下一跳联系。并且由于不知道下一跳的地址，第二跳需要等待第一跳把第三跳的地址传输过来，见下图。

![Untitled](Untitled_7.png)

所以这里每一跳能见到之后所有的ip地址，所有的流量和请求，及其不安全。

### 结论

socks5只是一个简单的代理方式，并不适合做任何隐私保护。